name,ring,quadrant,isNew,description
Infrastructure as code,Adopt,Techniques,FALSE,"<p>Although <strong>infrastructure as code</strong> is a relatively old technique (we’ve featured it in the Radar in 2011), it has become vitally important in the modern cloud era where the act of setting up infrastructure has become the passing of configuration instructions to a cloud platform. When we say ""as code"" we mean that all the good practices we've learned in the software world should be applied to infrastructure. Using source control, adhering to the <a href=""https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"">DRY principle</a>, modularization, maintainability, and using automated testing and deployment are all critical practices. Those of us with a deep software and infrastructure background need to empathize with and support colleagues who do not. Saying ""treat infrastructure like code"" isn't enough; we need to ensure the hard-won learnings from the software world are also applied consistently throughout the infrastructure realm.</p>"
Pipelines as code,Adopt,Techniques,FALSE,"<p>The <strong>pipelines as code</strong> technique emphasizes that the configuration of delivery pipelines that build, test and deploy our applications or infrastructure should be treated as code; they should be placed under source control and modularized in reusable components with automated testing and deployment. As organizations move to decentralized autonomous teams building <a href=""https://martinfowler.com/articles/microservices.html"">microservices</a> or <a href=""/radar/techniques/micro-frontends"">micro frontends</a>, the need for engineering practices in managing pipelines as code increases to keep building and deploying software consistent within the organization. This need has given rise to delivery pipeline templates and tooling that enable a standardized way to build and deploy services and applications. Such tools use the <em>declarative delivery pipelines</em> of applications, adopting a pipeline blueprint to execute the underlying tasks for various stages of a delivery lifecycle such as build, test and deployment; and they abstract away implementation details. The ability to build, test and deploy pipelines as code should be one of the evaluation criteria for choosing a CI/CD tool.</p>"
Simplest possible feature toggle,Adopt,Techniques,TRUE,"<p>Unfortunately, <a href=""https://martinfowler.com/articles/feature-toggles.html"">feature toggles</a> are less common than we'd like, and quite often we see people mixing up its types and use cases. It's quite common to come across teams that use heavyweight platforms such as <a href=""https://launchdarkly.com/"">LaunchDarkly</a> to implement feature toggles, including release toggles, to benefit from <a href=""https://martinfowler.com/articles/continuousIntegration.html"">Continuous Integration</a>, when all you need are if/else conditionals. Therefore, unless you need A/B testing or <a href=""https://martinfowler.com/bliki/CanaryRelease.html"">canary release</a> or hand over feature release responsibility to business folks, we encourage you to use the <strong>simplest possible feature toggle</strong> instead of unnecessarily complex feature toggle frameworks.</p>"
Ethical bias testing,Trial,Techniques,FALSE,"<p>Over the past year, we've seen a shift in interest around machine learning and deep neural networks in particular. Until now, tool and technique development has been driven by excitement over the remarkable capabilities of these models. Currently, though, there is rising concern that these models could cause unintentional harm. For example, a model could be trained inadvertently to make profitable credit decisions by simply excluding disadvantaged applicants. Fortunately, we're seeing a growing interest in <strong>ethical bias testing</strong> that will help to uncover potentially harmful decisions. Tools such as <a href=""https://github.com/marcotcr/lime"">lime</a>, <a href=""https://aif360.mybluemix.net/"">AI Fairness 360</a> or <a href=""/radar/tools/what-if-tool"">What-If Tool</a> can help uncover inaccuracies that result from underrepresented groups in training data and visualization tools such as <a href=""https://ai.googleblog.com/2017/07/facets-open-source-visualization-tool.html"">Google Facets</a> or <a href=""https://pair-code.github.io/facets/"">Facets Dive</a> can be used to discover subgroups within a corpus of training data. We've used lime (local interpretable model-agnostic explanations) in addition to this technique in order to understand the predictions of any machine-learning classifier and what classifiers (or models) are doing.</p>"
GraphQL for server-side resource aggregation,Trial,Techniques,FALSE,"<p>We see more and more tools such as <a href=""https://www.apollographql.com/docs/apollo-server/federation/introduction/"">Apollo Federation</a> that can aggregate multiple GraphQL endpoints into a single graph. However, we caution against misusing <a href=""/radar/languages-and-frameworks/graphql"">GraphQL</a>, especially when turning it into a server-to-server protocol. Our practice is to use <strong><a href=""/radar/techniques/graphql-for-server-side-resource-aggregation"">GraphQL for server-side resource aggregation</a></strong> only. When using this pattern, the microservices continue to expose well-defined RESTful APIs, while under-the-hood aggregate services or <a href=""/radar/techniques/bff-backend-for-frontends"">BFF (Backend for Frontends)</a> patterns use GraphQL resolvers as the implementation for stitching resources from other services. The shape of the graph is driven by domain-modeling exercises to ensure ubiquitous language is limited to subgraphs where needed (in the case of one-microservice-per-bounded-context). This technique simplifies the internal implementation of aggregate services or BFFs, while encouraging good modeling of services to avoid <a href=""/radar/techniques/anemic-rest"">anemic REST</a>.</p>"
Platform engineering product teams,Trial,Techniques,FALSE,"<p>The adoption of cloud and DevOps — while increasing the productivity of teams who can now move more quickly with reduced dependency on centralized operations teams and infrastructure — also has constrained teams that lack the skills to self-manage a full application and operations stack. Some organizations have tackled this challenge by creating <strong>platform engineering product teams</strong>. These teams maintain an internal platform that enables delivery teams to deploy and operate systems with reduced lead time and stack complexity. The emphasis here is on API-driven self-service and supporting tools, with delivery teams still responsible for supporting what they deploy onto the platform. Organizations that consider establishing such a platform team should be very cautious not to accidentally create a <a href=""/radar/techniques/separate-devops-team"">separate DevOps team</a>, nor should they simply relabel their <a href=""/radar/platforms/superficial-private-cloud"">existing hosting and operations structure</a> as a platform. If you're wondering how to best set up platform teams, we've been using the concepts from <a href=""https://teamtopologies.com/"">Team Topologies</a> to split platform teams in our projects into enablement teams, core ""platform within a platform"" teams and stream-focused teams.</p>"
Security policy as code,Trial,Techniques,FALSE,"<p>Security policies are rules and procedures that protect our systems from threats and disruption. For example, access control policies define and enforce who can access which services and resources under what circumstances; or network security policies can dynamically limit the traffic rate to a particular service. The complexity of the technology landscape today demands treating <strong>security policy as code</strong>: define and keep policies under version control, automatically validate them, automatically deploy them and monitor their performance. Tools such as <a href=""/radar/tools/open-policy-agent-opa"">Open Policy Agent</a> or platforms such as <a href=""/radar/platforms/istio"">Istio</a> provide flexible policy definition and enforcement mechanisms that support the practice of security policy as code.</p>"
Zero trust architecture (ZTA),Trial,Techniques,TRUE,"<p>The technology landscape of organizations today is increasingly more complex with assets — data, functions, infrastructure and users — spread across security boundaries, such as local hosts, multiple cloud providers and a variety of SaaS vendors. This demands a paradigm shift in enterprise security planning and systems architecture, moving from static and slow-changing security policy management, based on trust zones and network configurations, to dynamic, fine-grained security policy enforcement based on temporal access privileges.</p>

<p><strong>Zero trust architecture (ZTA)</strong> is an organization's strategy and journey to implement zero-trust security principles for all of their assets — such as devices, infrastructure, services, data and users — and includes implementing practices such as securing all access and communications regardless of the network location, enforcing policies as code based on the least privilege and as granular as possible, and continuous monitoring and automated mitigation of threats. Our Radar reflects many of the enabling techniques such as <a href=""/radar/techniques/security-policy-as-code"">security policy as code</a>, <a href=""/radar/techniques/sidecars-for-endpoint-security"">sidecars for endpoint security</a> and <a href=""/radar/techniques/beyondcorp"">BeyondCorp</a>. If you're on your journey toward ZTA, refer to the <a href=""https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207-draft2.pdf"">NIST ZTA publication</a> to learn more about principles, enabling technology components and migration patterns as well as Google's publication on <a href=""https://cloud.google.com/security/beyondprod"">BeyondProd</a>.</p>"
.NET Core,Adopt,Platforms,FALSE,"<p>We previously had <strong>.NET Core</strong> in Adopt, indicating that it had become our default for .NET projects. But we felt it's worth again calling attention to .NET Core. With the release of .NET Core 3.<em>x</em> last year, the bulk of the features from .NET Framework have now been ported into .NET Core. With the announcement that <a href=""https://devblogs.microsoft.com/dotnet/introducing-net-5"">.NET Framework is on its last release</a>, Microsoft have reinforced the view that <a href=""https://devblogs.microsoft.com/dotnet/net-core-is-the-future-of-net/"">.NET Core is the future of .NET</a>. Microsoft has done a lot of work to make .NET Core <a href=""https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/"">container friendly</a>. Most of our .NET Core–based projects target Linux and are often deployed as containers. The upcoming <a href=""https://devblogs.microsoft.com/dotnet/introducing-net-5/"">.NET 5</a> release looks promising, and we're looking forward to it.</p>"
Hot Chocolate,Trial,Platforms,FALSE,"<p>The <a href=""/radar/languages-and-frameworks/graphql"">GraphQL</a> ecosystem and community keep growing. <strong><a href=""https://hotchocolate.io/"">Hot Chocolate</a></strong> is a GraphQL server for .NET (Core and Classic). It lets you build and host schemas and then serve queries against them using the same base components of GraphQL — data loader, resolver, schema, operations and types. The team behind Hot Chocolate has recently added schema stitching, which allows for a single entry point to query across multiple schemas aggregated from different locations. Despite the potential to misuse this approach, our teams are happy with Hot Chocolate — it’s well documented, and we're able to deliver value quickly to our clients.</p>"
Cosmos,Assess,Platforms,TRUE,"<p>The performance of blockchain technology has been greatly improved since we <a href=""/radar/techniques/blockchain-beyond-bitcoin"">initially assessed</a> this area in the Radar. However, there's still no single blockchain that could achieve ""internet-level"" throughput. As various blockchain platforms develop, we're seeing new data and value silos. That's why cross-chain tech has always been a key topic in the blockchain community: the future of blockchain may be a network of independent parallel blockchains. This is also the vision of <strong><a href=""https://cosmos.network/"">Cosmos</a></strong>. Cosmos releases <a href=""/radar/platforms/tendermint"">Tendermint</a> and CosmosSDK to let developers customize independent blockchains. These parallel blockchains could exchange value through the Inter-Blockchain Communication (IBC) protocol and Peg-Zones. Our teams have had great experiences with CosmosSDK, and the IBC protocol is maturing. This architecture could solve blockchain interoperability and scalability issues.</p>"
Visual regression testing tools,Trial,Tools,FALSE,"<p>Since we first mentioned <strong>visual regression testing tools</strong> in 2014, the use of the technique has spread and the tools landscape has evolved. <a href=""/radar/tools/backstopjs"">BackstopJS</a> remains an excellent choice with new features being added regularly, including support for running inside Docker containers. <a href=""/radar/tools/loki"">Loki</a> was featured in our previous Radar. <a href=""https://applitools.com/"">Applitools</a>, <a href=""https://crossbrowsertesting.com/"">CrossBrowserTesting</a> and <a href=""https://percy.io/"">Percy</a> are SaaS solutions. Another notable mention is <a href=""https://github.com/rsmbl"">Resemble.js</a>, an image diffing library. Although most teams use it indirectly as part of BackstopJS, some of our teams have been using it to analyze and compare images of web pages directly. In general, our experience shows that visual regression tools are less useful in the early stages when the interface goes through significant changes, but they certainly prove their worth as the product matures and the interface stabilizes.</p>"
Visual Studio Live Share,Trial,Tools,FALSE,"<p><strong><a href=""https://marketplace.visualstudio.com/items?itemName=MS-vsliveshare.vsliveshare-pack"">Visual Studio Live Share</a></strong> is a suite of extensions for <a href=""/radar/tools/visual-studio-code"">Visual Studio Code</a> and Visual Studio. At a time when teams are searching for good remote collaboration options, we want to call attention to the excellent tooling here. Live Share provides a good, low-latency remote-pairing experience, and requires significantly less bandwidth than the brute-force approach of sharing your entire desktop. Importantly, developers can work with their preferred configuration, extensions and key mappings during a pairing session. In addition to real-time collaboration for editing and debugging code, Live Share allows voice calls and sharing terminals and servers.</p>"
Asp .Net Core,Adopt,Platforms,FALSE,"<p>We previously had <strong>.NET Core</strong> in Adopt, indicating that it had become our default for .NET projects. But we felt it's worth again calling attention to .NET Core. With the release of .NET Core 3.<em>x</em> last year, the bulk of the features from .NET Framework have now been ported into .NET Core. With the announcement that <a href=""https://devblogs.microsoft.com/dotnet/introducing-net-5"">.NET Framework is on its last release</a>, Microsoft have reinforced the view that <a href=""https://devblogs.microsoft.com/dotnet/net-core-is-the-future-of-net/"">.NET Core is the future of .NET</a>. Microsoft has done a lot of work to make .NET Core <a href=""https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/"">container friendly</a>. Most of our .NET Core–based projects target Linux and are often deployed as containers. The upcoming <a href=""https://devblogs.microsoft.com/dotnet/introducing-net-5/"">.NET 5</a> release looks promising, and we're looking forward to it.</p>"
Chef,Legacy,Platforms,FALSE,<p>Used to deploy Landscape client and other Legacy components into our CI/CD environments. We are slowly disconnecting from this.</p>
Docker,Assess,Platforms,TRUE,"<p>Container technology that utilizes an ultra-slim windows server or Linux image that is simple to build and deploy with, and can form part of a Kubernetes or Fabric cluster. Currently used for our deployment agents. This may start to become more widely adpoted as we find further uses for it.</p>"
Azure Event Grid,Adopt,Platforms,TRUE,<p></p>
Azure DevOps,Assess,Intrastructure,TRUE,<p></p>
ElasticSearch,Assess,Platforms,TRUE,"<p>An indexing platform for cross-domain, full-text fuzzy search capability.</p>"
Azure Cognitive Search,Assess,Platforms,TRUE,<p>An easy-to-consume indexing platform for full-text fuzzy search capability.</p>
Git Repository,Adopt,Source Control,TRUE,"<p>The source control system of choice, based on local a local repository principle to allow developers easier control of source. This allows us to remove trunk 'locking' impediments and also represents a 1:1 map with the files system, reducing complexity around modification of the solution structure. Already used for Release Hub artefacts.</p>"
TFS Repository,Maintain,Source Control,FALSE,<p>Maintained while we move towards Git</p>
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
